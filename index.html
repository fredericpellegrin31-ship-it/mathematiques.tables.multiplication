<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bataille Navale des Multiplications - CE1</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #0ea5e9; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; }
        
        /* Menu d'accueil */
        #home-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, #0ea5e9, #075985);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 300;
            color: white;
            text-align: center;
        }

        .menu-card {
            background: rgba(15, 23, 42, 0.8);
            padding: 40px;
            border-radius: 20px;
            border: 4px solid #eab308;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.5);
        }

        .level-btn {
            display: block;
            width: 250px;
            margin: 15px auto;
            padding: 15px;
            font-size: 1.2rem;
            font-weight: bold;
            color: #0f172a;
            background: #f1f5f9;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s, background 0.2s;
        }

        .level-btn:hover {
            transform: scale(1.05);
            background: #eab308;
        }

        /* Interface de jeu */
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(15, 23, 42, 0.9);
            padding: 20px;
            border-radius: 15px;
            border: 3px solid #eab308;
            pointer-events: none;
            z-index: 10;
            min-width: 250px;
        }

        #timer-container {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 200px;
            height: 30px;
            background: rgba(0,0,0,0.5);
            border-radius: 15px;
            border: 2px solid white;
            overflow: hidden;
            z-index: 10;
        }

        #timer-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(to right, #22c55e, #eab308, #ef4444);
            transition: width 1s linear;
        }

        .math-box { font-size: 2.5rem; font-weight: bold; color: #fbbf24; margin: 10px 0; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); }
        .controls-hint { font-size: 0.8rem; color: #94a3b8; margin-top: 10px; line-height: 1.4; }
        
        #message { position: absolute; bottom: 25%; width: 100%; text-align: center; color: #fbbf24; font-size: 3rem; font-weight: bold; pointer-events: none; display: none; text-shadow: 3px 3px 6px #000; z-index: 20; }
        
        #game-over {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 400;
            text-align: center;
        }
    </style>
</head>
<body>

<div id="home-screen">
    <div class="menu-card">
        <h1 style="font-size: 3rem; margin-bottom: 10px;">Bataille Navale</h1>
        <p style="font-size: 1.2rem; margin-bottom: 30px; color: #cbd5e1;">Apprends tes tables en haute mer !</p>
        <button class="level-btn" onclick="startGame(2, 5)">DÉBUTANT (Tables 2 à 5)</button>
        <button class="level-btn" onclick="startGame(2, 10)">MOUSSAILLON (Tables 2 à 10)</button>
        <button class="level-btn" onclick="startGame(11, 15)">CAPITAINE (Tables 11 à 15)</button>
    </div>
</div>

<div id="ui" style="display:none;">
    <h2 style="margin:0; font-size: 1.2rem; color: #eab308;">Capitaine !</h2>
    <div id="math-question" class="math-box">...</div>
    <p style="margin: 5px 0; font-size: 1.2rem;">Score : <span id="score" style="color:#22c55e">0</span></p>
    <div class="controls-hint">
        Z,Q,S,D : Naviguer | <b>ESPACE : Tirer</b><br>
        <b>C : Changer de vue</b> (actuelle: <span id="view-name">Classique</span>)
    </div>
</div>

<div id="timer-container" style="display:none;"><div id="timer-bar"></div></div>
<div id="message">BIEN JOUÉ !</div>

<div id="game-over">
    <h1 style="font-size: 4rem; color: #eab308;">Temps écoulé !</h1>
    <p style="font-size: 2rem;">Votre score final : <span id="final-score">0</span></p>
    <button class="level-btn" onclick="location.reload()" style="background:#eab308">RETOUR AU MENU</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/loaders/MTLLoader.js"></script>
<script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/loaders/OBJLoader.js"></script>

<script>
/**
 * ÉTAT ET CONFIGURATION
 */
let scene, camera, renderer, playerShip;
let score = 0;
let timeLeft = 120;
let isGameOver = false;
let currentQuestion = { a: 0, b: 0, answer: 0 };
let levelConfig = { min: 2, max: 10 };
const loadedModels = {};
const enemies = [];
const rocks = [];
const cannonBalls = [];
const keys = {};

// Caméras
let currentViewIndex = 0;
const views = ["Classique", "Proue", "Aérienne"];

const moveState = { speed: 0, rotation: 0, maxSpeed: 0.35, acceleration: 0.015, friction: 0.97 };

function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb);
    scene.fog = new THREE.Fog(0x87ceeb, 20, 400);

    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0xffffff, 0.9));
    const sun = new THREE.DirectionalLight(0xffffff, 0.6);
    sun.position.set(100, 100, 50);
    scene.add(sun);

    const oceanGeo = new THREE.PlaneGeometry(5000, 5000);
    const oceanMat = new THREE.MeshPhongMaterial({ color: 0x0ea5e9, shininess: 90, transparent: true, opacity: 0.9 });
    const ocean = new THREE.Mesh(oceanGeo, oceanMat);
    ocean.rotation.x = -Math.PI / 2;
    scene.add(ocean);

    window.addEventListener('keydown', (e) => {
        keys[e.code] = true;
        if(e.code === 'Space' && !isGameOver) fireCannon();
        if(e.code === 'KeyC') toggleView();
    });
    window.addEventListener('keyup', (e) => keys[e.code] = false);

    loadAssets();
}

function startGame(min, max) {
    levelConfig = { min, max };
    document.getElementById('home-screen').style.display = 'none';
    document.getElementById('ui').style.display = 'block';
    document.getElementById('timer-container').style.display = 'block';
    setupWorld();
}

async function loadAssets() {
    const objLoader = new THREE.OBJLoader();
    const mtlLoader = new THREE.MTLLoader();

    // Configuration des fichiers correspondants aux ressources montées
    const modelsToLoad = {
        ship: { obj: 'ship-medium.obj', mtl: 'ship-medium.mtl' },
        rock: { obj: 'rocks-a.obj', mtl: 'rocks-a.mtl' },
        ball: { obj: 'cannon-ball.obj', mtl: 'cannon-ball.mtl' }
    };

    for(const [name, paths] of Object.entries(modelsToLoad)) {
        try {
            // Chargement du MTL d'abord
            const materials = await new Promise((resolve, reject) => {
                mtlLoader.load(paths.mtl, resolve, undefined, reject);
            });
            materials.preload();
            
            // Liaison des matériaux à l'OBJ loader
            objLoader.setMaterials(materials);
            
            // Chargement de l'OBJ avec ses matériaux liés
            const object = await new Promise((resolve, reject) => {
                objLoader.load(paths.obj, resolve, undefined, reject);
            });
            
            loadedModels[name] = object;
        } catch(e) {
            console.warn(`Erreur de chargement pour ${name}, utilisation d'un mesh par défaut`, e);
            loadedModels[name] = new THREE.Mesh(
                new THREE.BoxGeometry(2,2,2), 
                new THREE.MeshStandardMaterial({color: name === 'ball' ? 0x333333 : 0x666666})
            );
        }
    }
}

function setupWorld() {
    if (!loadedModels.ship) return;

    playerShip = loadedModels.ship.clone();
    scene.add(playerShip);

    for(let i=0; i<70; i++) {
        const r = loadedModels.rock.clone();
        const dist = 70 + Math.random() * 300;
        const ang = Math.random() * Math.PI * 2;
        r.position.set(Math.cos(ang)*dist, -0.5, Math.sin(ang)*dist);
        r.scale.setScalar(2 + Math.random() * 5);
        r.userData.collisionRadius = r.scale.x * 1.8;
        scene.add(r);
        rocks.push(r);
    }

    startTimer();
    generateQuestion();
    animate();
}

function toggleView() {
    currentViewIndex = (currentViewIndex + 1) % views.length;
    document.getElementById('view-name').innerText = views[currentViewIndex];
}

function startTimer() {
    const timerBar = document.getElementById('timer-bar');
    const interval = setInterval(() => {
        if (isGameOver) { clearInterval(interval); return; }
        timeLeft--;
        timerBar.style.width = (timeLeft / 120 * 100) + "%";
        if (timeLeft <= 0) {
            isGameOver = true;
            document.getElementById('game-over').style.display = 'flex';
            document.getElementById('final-score').innerText = score;
            clearInterval(interval);
        }
    }, 1000);
}

function generateQuestion() {
    currentQuestion.a = Math.floor(Math.random() * (levelConfig.max - levelConfig.min + 1)) + levelConfig.min;
    currentQuestion.b = Math.floor(Math.random() * 10) + 1;
    currentQuestion.answer = currentQuestion.a * currentQuestion.b;
    document.getElementById('math-question').innerText = `${currentQuestion.a} x ${currentQuestion.b} = ?`;
    spawnEnemies();
}

function spawnEnemies() {
    enemies.forEach(e => scene.remove(e));
    enemies.length = 0;

    const answers = [currentQuestion.answer];
    while(answers.length < 3) {
        let wrong = currentQuestion.answer + (Math.random() < 0.5 ? -1 : 1) * (Math.floor(Math.random() * 5) + 1);
        if (wrong > 0 && !answers.includes(wrong)) answers.push(wrong);
    }
    answers.sort(() => Math.random() - 0.5);

    answers.forEach((val, i) => {
        const ship = loadedModels.ship.clone();
        const angle = (Math.PI * 2 / 3) * i + (playerShip.rotation.y) + 0.5;
        const dist = 60 + Math.random() * 10;
        ship.position.set(playerShip.position.x + Math.sin(angle)*dist, 0, playerShip.position.z + Math.cos(angle)*dist);
        ship.userData = { value: val, isCorrect: val === currentQuestion.answer };
        
        const sprite = createTextSprite(val.toString());
        sprite.position.y = 12; // Nombres surélevés
        ship.add(sprite);

        scene.add(ship);
        enemies.push(ship);
    });
}

function createTextSprite(text) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 256; canvas.height = 128;
    ctx.fillStyle = '#fbbf24';
    ctx.font = 'Bold 110px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(text, 128, 100);
    const texture = new THREE.CanvasTexture(canvas);
    const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: texture }));
    sprite.scale.set(14, 7, 1);
    return sprite;
}

function fireCannon() {
    const ball = loadedModels.ball.clone();
    ball.position.copy(playerShip.position).add(new THREE.Vector3(0, 2, 0));
    const dir = new THREE.Vector3(0, 0, 1).applyQuaternion(playerShip.quaternion);
    ball.userData = { velocity: dir.multiplyScalar(1.5), life: 120 };
    scene.add(ball);
    cannonBalls.push(ball);
    moveState.speed -= 0.05; 
}

function updateProjectiles() {
    for (let i = cannonBalls.length - 1; i >= 0; i--) {
        const b = cannonBalls[i];
        b.position.add(b.userData.velocity);
        b.userData.life--;
        
        for (let j = enemies.length - 1; j >= 0; j--) {
            if (b.position.distanceTo(enemies[j].position) < 7) {
                checkImpact(enemies[j], j);
                scene.remove(b);
                cannonBalls.splice(i, 1);
                return;
            }
        }
        if (b.userData.life <= 0) { scene.remove(b); cannonBalls.splice(i, 1); }
    }
}

function checkImpact(enemy, idx) {
    if (enemy.userData.isCorrect) {
        score += 10;
        document.getElementById('score').innerText = score;
        showMessage("EXCELLENT ! +10");
        generateQuestion();
    } else {
        score = Math.max(0, score - 5);
        document.getElementById('score').innerText = score;
        showMessage("ERREUR ! -5", "#ef4444");
        scene.remove(enemy);
        enemies.splice(idx, 1);
        if(enemies.length === 0) generateQuestion();
    }
}

function animate() {
    if (isGameOver) return;
    requestAnimationFrame(animate);

    if (keys['KeyW'] || keys['ArrowUp']) moveState.speed += moveState.acceleration;
    if (keys['KeyS'] || keys['ArrowDown']) moveState.speed -= moveState.acceleration;
    if (keys['KeyA'] || keys['ArrowLeft']) playerShip.rotation.y += 0.035;
    if (keys['KeyD'] || keys['ArrowRight']) playerShip.rotation.y -= 0.035;

    moveState.speed *= moveState.friction;
    const oldPos = playerShip.position.clone();
    playerShip.translateZ(moveState.speed);

    for(const r of rocks) {
        if(playerShip.position.distanceTo(r.position) < r.userData.collisionRadius) {
            playerShip.position.copy(oldPos);
            moveState.speed = -moveState.speed * 0.4;
            break;
        }
    }

    let targetCamPos = new THREE.Vector3();
    let lookAtPos = playerShip.position.clone().add(new THREE.Vector3(0, 2, 0));

    if (views[currentViewIndex] === "Classique") {
        targetCamPos.copy(new THREE.Vector3(0, 18, -35)).applyMatrix4(playerShip.matrixWorld);
    } else if (views[currentViewIndex] === "Proue") {
        targetCamPos.copy(new THREE.Vector3(0, 4, 8)).applyMatrix4(playerShip.matrixWorld);
        lookAtPos.add(new THREE.Vector3(0, 0, 20).applyQuaternion(playerShip.quaternion));
    } else if (views[currentViewIndex] === "Aérienne") {
        targetCamPos.copy(playerShip.position).add(new THREE.Vector3(0, 80, -20));
    }

    camera.position.lerp(targetCamPos, 0.1);
    camera.lookAt(lookAtPos);

    updateProjectiles();

    const t = Date.now() * 0.002;
    playerShip.position.y = Math.sin(t) * 0.15;
    playerShip.rotation.x = Math.cos(t * 0.5) * 0.02;

    renderer.render(scene, camera);
}

function showMessage(txt, color = "#fbbf24") {
    const el = document.getElementById('message');
    el.innerText = txt; el.style.color = color; el.style.display = 'block';
    setTimeout(() => el.style.display = 'none', 1500);
}

window.onresize = () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
};

window.onload = init;
</script>
</body>
</html>
