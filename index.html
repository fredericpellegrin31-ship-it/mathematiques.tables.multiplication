<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bataille des Tables 3D</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; }
        
        /* Menu et UI */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            color: white;
            text-shadow: 2px 2px 8px rgba(0,0,0,0.8);
        }

        .menu-card {
            background: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            pointer-events: auto;
            border: 2px solid #f1c40f;
            max-width: 400px;
        }

        .btn {
            display: block;
            width: 100%;
            padding: 15px;
            margin: 10px 0;
            font-size: 1.2rem;
            cursor: pointer;
            background: #e67e22;
            color: white;
            border: none;
            border-radius: 8px;
            transition: transform 0.2s, background 0.2s;
        }

        .btn:hover {
            background: #d35400;
            transform: scale(1.05);
        }

        #game-info {
            position: absolute;
            top: 20px;
            width: 100%;
            display: flex;
            justify-content: space-around;
            font-size: 1.5rem;
            font-weight: bold;
            display: none;
        }

        #question-display {
            background: rgba(0,0,0,0.6);
            padding: 10px 30px;
            border-radius: 30px;
            border: 2px solid white;
        }

        .hidden { display: none !important; }
        
        #feedback {
            position: absolute;
            top: 50%;
            font-size: 3rem;
            font-weight: bold;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
        }
    </style>
</head>
<body>
    <div id="ui-layer">
        <!-- Menu Principal -->
        <div id="main-menu" class="menu-card">
            <h1>Pirates des Tables</h1>
            <p>Choisissez votre difficulté :</p>
            <button class="btn" onclick="startGame(1)">Niveau 1 (Tables 2, 4, 5, 10)</button>
            <button class="btn" onclick="startGame(2)">Niveau 2 (Tables 2 à 7, 10)</button>
            <button class="btn" onclick="startGame(3)">Niveau 3 (Tables 2 à 10)</button>
        </div>

        <!-- Interface de Jeu -->
        <div id="game-info">
            <div id="question-display">Calculez...</div>
            <div id="score-display">Score: 0</div>
        </div>
        
        <div id="feedback">BIEN JOUÉ !</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        let scene, camera, renderer, ship;
        let targets = [];
        let currentLevel = 0;
        let score = 0;
        let currentQuestion = { a: 0, b: 0, answer: 0 };
        let gameActive = false;

        const levels = {
            1: [2, 4, 5, 10],
            2: [2, 3, 4, 5, 6, 7, 10],
            3: [2, 3, 4, 5, 6, 7, 8, 9, 10]
        };

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 8, 20);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Lumières
            scene.add(new THREE.AmbientLight(0xffffff, 0.7));
            const sun = new THREE.DirectionalLight(0xffffff, 0.8);
            sun.position.set(5, 10, 7);
            scene.add(sun);

            createOcean();
            createShip();
            
            window.addEventListener('resize', onWindowResize);
            animate();
        }

        function createOcean() {
            const geo = new THREE.PlaneGeometry(500, 500);
            const mat = new THREE.MeshPhongMaterial({ color: 0x006994, transparent: true, opacity: 0.9 });
            const water = new THREE.Mesh(geo, mat);
            water.rotation.x = -Math.PI / 2;
            scene.add(water);
        }

        function createShip() {
            ship = new THREE.Group();
            // Coque simplifiée
            const hull = new THREE.Mesh(new THREE.BoxGeometry(4, 1.5, 7), new THREE.MeshPhongMaterial({ color: 0x5d4037 }));
            hull.position.y = 0.75;
            ship.add(hull);
            
            // Mât
            const mast = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 5), new THREE.MeshPhongMaterial({ color: 0x3e2723 }));
            mast.position.y = 3.5;
            ship.add(mast);

            scene.add(ship);
        }

        function startGame(level) {
            currentLevel = level;
            score = 0;
            gameActive = true;
            
            document.getElementById('main-menu').classList.add('hidden');
            document.getElementById('game-info').style.display = 'flex';
            document.getElementById('score-display').innerText = `Score: ${score}`;
            
            nextQuestion();
        }

        function nextQuestion() {
            const possibleTables = levels[currentLevel];
            const a = possibleTables[Math.floor(Math.random() * possibleTables.length)];
            const b = Math.floor(Math.random() * 11); // 0 à 10
            
            currentQuestion = { a, b, answer: a * b };
            document.getElementById('question-display').innerText = `${a} x ${b} = ?`;
            
            generateTargets();
        }

        function generateTargets() {
            // Nettoyer les anciennes cibles
            targets.forEach(t => scene.remove(t.mesh));
            targets = [];

            const answers = [currentQuestion.answer];
            // Générer 2 fausses réponses
            while(answers.length < 3) {
                const wrong = currentQuestion.answer + (Math.floor(Math.random() * 5) + 1) * (Math.random() > 0.5 ? 1 : -1);
                if (wrong >= 0 && !answers.includes(wrong)) answers.push(wrong);
            }
            
            // Mélanger
            answers.sort(() => Math.random() - 0.5);

            // Créer les objets 3D (bouées)
            answers.forEach((val, i) => {
                const group = new THREE.Group();
                
                // Bouée
                const buoy = new THREE.Mesh(
                    new THREE.SphereGeometry(1.2, 16, 16),
                    new THREE.MeshPhongMaterial({ color: 0xff4444 })
                );
                group.add(buoy);

                // Texte (Canvas Texture)
                const canvas = document.createElement('canvas');
                canvas.width = 128;
                canvas.height = 128;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = 'white';
                ctx.font = 'bold 60px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(val, 64, 80);
                
                const texture = new THREE.CanvasTexture(canvas);
                const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: texture }));
                sprite.position.y = 2;
                sprite.scale.set(3, 3, 1);
                group.add(sprite);

                group.position.set((i - 1) * 8, 1, -15);
                group.userData = { value: val };
                
                scene.add(group);
                targets.push({ mesh: group, value: val });
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Détection du clic sur une cible
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        window.addEventListener('mousedown', (event) => {
            if (!gameActive) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(targets.map(t => t.mesh), true);

            if (intersects.length > 0) {
                // Trouver l'objet parent (le groupe)
                let obj = intersects[0].object;
                while(obj.parent && !obj.userData.value) obj = obj.parent;
                
                handleAnswer(obj.userData.value);
            }
        });

        function handleAnswer(val) {
            const feedback = document.getElementById('feedback');
            
            if (val === currentQuestion.answer) {
                score += 10;
                feedback.innerText = "BIEN JOUÉ !";
                feedback.style.color = "#2ecc71";
                showFeedback();
                nextQuestion();
            } else {
                score = Math.max(0, score - 5);
                feedback.innerText = "OUPS !";
                feedback.style.color = "#e74c3c";
                showFeedback();
            }
            document.getElementById('score-display').innerText = `Score: ${score}`;
        }

        function showFeedback() {
            const feedback = document.getElementById('feedback');
            feedback.style.opacity = '1';
            setTimeout(() => { feedback.style.opacity = '0'; }, 1000);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;

            if (ship) {
                ship.rotation.z = Math.sin(time) * 0.05;
                ship.position.y = Math.sin(time * 0.5) * 0.2;
            }

            targets.forEach(t => {
                t.mesh.position.y = 1 + Math.sin(time + t.mesh.position.x) * 0.3;
            });

            renderer.render(scene, camera);
        }

            init();
    </script>
</body>
</html>

