<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bataille Navale des Multiplications - CE1</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87ceeb; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(15, 23, 42, 0.9);
            padding: 25px;
            border-radius: 15px;
            border: 3px solid #eab308;
            pointer-events: none;
            z-index: 10;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
        }
        #loading-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #0f172a;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 100;
        }
        .loader {
            border: 5px solid #1e293b;
            border-top: 5px solid #eab308;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .math-box { font-size: 3rem; font-weight: bold; color: #fbbf24; margin: 10px 0; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); }
        .controls-hint { font-size: 0.9rem; color: #94a3b8; margin-top: 10px; }
        #message { position: absolute; bottom: 20%; width: 100%; text-align: center; color: #fbbf24; font-size: 2rem; font-weight: bold; pointer-events: none; display: none; text-shadow: 2px 2px 4px #000; }
    </style>
</head>
<body>

<div id="loading-screen">
    <div class="loader"></div>
    <p id="status">Chargement de la zone de combat...</p>
</div>

<div id="ui">
    <h2 style="margin:0; font-size: 1.4rem; color: #eab308;">Capitaine, trouvez le bon navire !</h2>
    <div id="math-question" class="math-box">...</div>
    <p style="margin: 5px 0; font-size: 1.2rem;">Score : <span id="score" style="color:#22c55e">0</span></p>
    <div class="controls-hint">Touches Z, Q, S, D ou Flèches pour naviguer</div>
</div>

<div id="message">BIEN JOUÉ !</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/loaders/MTLLoader.js"></script>
<script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/loaders/OBJLoader.js"></script>

<script>
/**
 * CONFIGURATION ET ÉTAT DU JEU
 */
const assets = {
    ship: { obj: 'ship-medium.obj', mtl: 'ship-medium.mtl' },
    rock: { obj: 'rocks-a.obj', mtl: 'rocks-a.mtl' },
    cannon: { obj: 'cannon.obj', mtl: 'cannon.mtl' },
    ball: { obj: 'cannon-ball.obj', mtl: 'cannon-ball.mtl' }
};

let scene, camera, renderer, playerShip;
let score = 0;
let currentQuestion = { a: 0, b: 0, answer: 0 };
const loadedModels = {};
const enemies = [];
const keys = {};

// Paramètres de mouvement
const moveState = { speed: 0, rotation: 0, maxSpeed: 0.3, acceleration: 0.01, friction: 0.98 };

function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb);
    scene.fog = new THREE.Fog(0x87ceeb, 20, 250);

    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0xffffff, 0.8));
    const sun = new THREE.DirectionalLight(0xffffff, 0.6);
    sun.position.set(100, 100, 50);
    sun.castShadow = true;
    scene.add(sun);

    // Océan infini
    const oceanGeo = new THREE.PlaneGeometry(2000, 2000);
    const oceanMat = new THREE.MeshPhongMaterial({ color: 0x0ea5e9, shininess: 80, transparent: true, opacity: 0.9 });
    const ocean = new THREE.Mesh(oceanGeo, oceanMat);
    ocean.rotation.x = -Math.PI / 2;
    scene.add(ocean);

    window.addEventListener('keydown', (e) => keys[e.code] = true);
    window.addEventListener('keyup', (e) => keys[e.code] = false);

    loadAllAssets();
}

async function loadAllAssets() {
    const objLoader = new THREE.OBJLoader();
    const mtlLoader = new THREE.MTLLoader();

    const loadModel = async (name, paths) => {
        try {
            // Charger les matériaux (.mtl)
            const mtlRes = await fetch(paths.mtl);
            const mtlText = await mtlRes.text();
            const materials = mtlLoader.parse(mtlText);
            materials.preload();

            // Charger la géométrie (.obj) avec les matériaux appliqués
            const objRes = await fetch(paths.obj);
            const objText = await objRes.text();
            
            objLoader.setMaterials(materials);
            const object = objLoader.parse(objText);
            loadedModels[name] = object;
        } catch (err) {
            console.warn(`Erreur ${name}, utilisation fallback.`);
            loadedModels[name] = createFallback(name);
        }
    };

    await Promise.all(Object.keys(assets).map(k => loadModel(k, assets[k])));
    setupGame();
}

function createFallback(name) {
    const geo = name === 'ship' ? new THREE.BoxGeometry(4, 2, 8) : new THREE.DodecahedronGeometry(2);
    const mat = new THREE.MeshStandardMaterial({ color: name === 'ship' ? 0x5d4037 : 0x757575 });
    return new THREE.Mesh(geo, mat);
}

function setupGame() {
    document.getElementById('loading-screen').style.display = 'none';
    
    // Navire joueur
    playerShip = loadedModels.ship.clone();
    playerShip.position.set(0, 0, 0);
    scene.add(playerShip);

    // Placement de rochers pour décorer
    for(let i=0; i<40; i++) {
        const r = loadedModels.rock.clone();
        const dist = 50 + Math.random() * 200;
        const ang = Math.random() * Math.PI * 2;
        r.position.set(Math.cos(ang)*dist, -0.5, Math.sin(ang)*dist);
        r.scale.setScalar(2 + Math.random() * 3);
        r.rotation.y = Math.random() * Math.PI;
        scene.add(r);
    }

    generateQuestion();
    animate();
}

function generateQuestion() {
    // Tables de 2 à 5 pour le CE1
    currentQuestion.a = Math.floor(Math.random() * 4) + 2; 
    currentQuestion.b = Math.floor(Math.random() * 10) + 1;
    currentQuestion.answer = currentQuestion.a * currentQuestion.b;

    document.getElementById('math-question').innerText = `${currentQuestion.a} x ${currentQuestion.b} = ?`;
    
    spawnEnemies();
}

function spawnEnemies() {
    // Nettoyer anciens ennemis
    enemies.forEach(e => scene.remove(e));
    enemies.length = 0;

    const results = [currentQuestion.answer];
    while(results.length < 3) {
        let wrong = currentQuestion.answer + (Math.random() < 0.5 ? -1 : 1) * (Math.floor(Math.random() * 5) + 1);
        if (wrong > 0 && !results.includes(wrong)) results.push(wrong);
    }
    // Mélanger
    results.sort(() => Math.random() - 0.5);

    results.forEach((val, i) => {
        const ship = loadedModels.ship.clone();
        const angle = (Math.PI * 2 / 3) * i + (playerShip.rotation.y);
        const dist = 40 + Math.random() * 20;
        
        ship.position.set(
            playerShip.position.x + Math.sin(angle) * dist,
            0,
            playerShip.position.z + Math.cos(angle) * dist
        );
        ship.userData = { value: val, isCorrect: val === currentQuestion.answer };
        
        // Ajouter le texte au dessus du bateau (Canvas texture)
        const sprite = createTextSprite(val.toString());
        sprite.position.y = 8;
        ship.add(sprite);

        scene.add(ship);
        enemies.push(ship);
    });
}

function createTextSprite(text) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 256;
    canvas.height = 128;
    ctx.fillStyle = '#eab308';
    ctx.font = 'Bold 100px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(text, 128, 100);
    
    const texture = new THREE.CanvasTexture(canvas);
    const spriteMat = new THREE.SpriteMaterial({ map: texture });
    const sprite = new THREE.Sprite(spriteMat);
    sprite.scale.set(10, 5, 1);
    return sprite;
}

function updateMovement() {
    if (keys['KeyW'] || keys['ArrowUp']) moveState.speed += moveState.acceleration;
    if (keys['KeyS'] || keys['ArrowDown']) moveState.speed -= moveState.acceleration;
    if (keys['KeyA'] || keys['ArrowLeft']) playerShip.rotation.y += 0.03;
    if (keys['KeyD'] || keys['ArrowRight']) playerShip.rotation.y -= 0.03;

    moveState.speed *= moveState.friction;
    if (Math.abs(moveState.speed) > moveState.maxSpeed) moveState.speed = Math.sign(moveState.speed) * moveState.maxSpeed;

    playerShip.translateZ(moveState.speed);

    // Caméra suit le bateau
    const relativeCameraOffset = new THREE.Vector3(0, 15, -25);
    const cameraOffset = relativeCameraOffset.applyMatrix4(playerShip.matrixWorld);
    camera.position.lerp(cameraOffset, 0.1);
    camera.lookAt(playerShip.position.x, playerShip.position.y + 2, playerShip.position.z);
}

function checkCollisions() {
    const playerPos = playerShip.position;
    
    for (let i = enemies.length - 1; i >= 0; i--) {
        const enemy = enemies[i];
        const dist = playerPos.distanceTo(enemy.position);
        
        if (dist < 6) { // Collision !
            if (enemy.userData.isCorrect) {
                score += 10;
                document.getElementById('score').innerText = score;
                showMessage("BRAVO ! +10");
                generateQuestion();
            } else {
                score = Math.max(0, score - 5);
                document.getElementById('score').innerText = score;
                showMessage("OUPS ! -5", "#ef4444");
                // On ne change pas la question, l'élève doit trouver la bonne
                scene.remove(enemy);
                enemies.splice(i, 1);
            }
        }
    }
}

function showMessage(txt, color = "#fbbf24") {
    const el = document.getElementById('message');
    el.innerText = txt;
    el.style.color = color;
    el.style.display = 'block';
    setTimeout(() => el.style.display = 'none', 1500);
}

function animate() {
    requestAnimationFrame(animate);
    const time = Date.now() * 0.001;

    updateMovement();
    checkCollisions();

    // Effet de vagues sur le joueur
    playerShip.position.y = Math.sin(time * 2) * 0.15;
    playerShip.rotation.x = Math.sin(time) * 0.02;

    renderer.render(scene, camera);
}

window.onresize = () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
};

window.onload = init;
</script>
</body>
</html>

